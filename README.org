* Grafter

Exploring the use of Clojure for RDFizing, DSL's, RDF tooling and more
tightly integrating with triple stores.

Grafter has a number of stated aims:

1) To show that Clojure could provide us with a number of platform
   benefits:

   - Easy access to Java tooling & API's, including the ability to
     talk direct to underlying triple store implementations.
   - Simplified infrastructure due to excellent concurrency support
     etc.
   - Potentially better performance by
     + Utilising local disk backed, indexed triple stores with no
       additional infrastructure overhead
     + Using a more performant language
     + Potentially skipping unnecessary serialization/parsing steps
   - Being able to create and manage logical graphs/endpoints more
     easily.

2) To show that Clojure is a near perfect tool for building an
   RDFization DSL which has a number of desirable properties that
   would be harder to achieve with more conventional approaches.

* RDFizing

In terms of RDFization the core idea is:

1) To build up a decent library of low level functions for common
   RDFing tasks.

2) To build a DSL with a simplified, consistent syntax that can be
   easily targetted by tooling etc...  The idea here is that the DSL's
   syntax will be built purely in terms of [[https://github.com/edn-format/edn][Extensible Data Notation]].

   (EDN is sort of like JSON, except it's syntactically Clojure,
   supports more data types and collections, and is extensible.
   API's for parsing and writing EDN are available in lots of
   languages including [[https://github.com/relevance/edn-ruby][Ruby]] and [[https://github.com/shaunxcode/jsedn][Javascript]])

   Above the syntactic layer Grafter should try and provide a language
   of operations that are simple enough for basic end user tooling,
   whilst ensuring sane (non-turing complete) semantics.

   As the grafter DSL snippets will also be valid Clojure programs,
   DSL forms will be literally copy/pastable inside arbitrary Clojure
   programs.

3) Grafter should aim to be a componentized workflow language, where
   logging, error reporting and more advanced features such as
   debugging, tracing and the configuration of concrete
   implementations can be easily applied by either the environment or
   a user to arbitrary pipelines without having to modify the pipeline
   itself.

We refer to the lower-level of grafter as the Grafter API and the
higher level as the grafter DSL.  Sometimes functions may be both part
of the DSL and the API so the distinction is not necessarily always
clear cut.

** Grafter API

Some namespace declarations to import the libraries:

#+BEGIN_SRC clojure
(ns grafter.rdf-examples
  (:use [grafter.rdf]
        [grafter.rdf.sesame])
  (:require [grafter.rdf.protocols :as pr]))
#+END_SRC

Create and initialise a sesame native-store repository on disk:

#+BEGIN_SRC clojure
(def my-repo (-> "./tmp/grafter-sesame-store" native-store repo))
#+END_SRC

Or use an in memory store:

#+BEGIN_SRC clojure
(def my-memory-repo (-> "./tmp/grafter-sesame-store" memory-store repo))
#+END_SRC

Want to add some triples to your store?  The triplify function takes
a sequence of turtle style rdf subjects and expands them into a
lazy-seq of Triple records:

#+BEGIN_SRC clojure
(triplify ["http://test.org/bob"
            ["http://is/a" "http://class/Person"]
            ["http://rdfs/label" (s "Bob Jones")]
            ["http://date-of-birth/" #inst "1980-01-02"]])

;; => (#grafter.rdf.protocols.Triple{:s "http://test.org/bob", :p "http://is/a", :o "http://class/Person"} #grafter.rdf.protocols.Triple{:s "http://test.org/bob", :p "http://rdfs/label", :o #<rdf$s$reify__1888 Bob Jones>} #grafter.rdf.protocols.Triple{:s "http://test.org/bob", :p "http://date-of-birth/", :o #inst "1980-01-02T00:00:00.000-00:00"})
#+END_SRC

*Note* how triplify assumes Strings in object position are URI's, if
you want a string wrap it in a call to =(s "String Value")=.  =s= also
takes an optional language tag or URI =(s "Bonjour!" "fr")=

Additionally =java.util.Date= is also expanded into xsd dateTime's,
which means you can use EDN =#inst= data literals too.

You can add Statements or sequences of statements to your store like
so with the =grafter.rdf.protocols/add= function:

#+BEGIN_SRC clojure
(pr/add repo (expand-subject ["http://test.org/bob"
                                ["http://is/a" "http://class/Person"]
                                ["http://rdfs/label" (s "Bob Jones")]
                                ["http://date-of-birth/" #inst "1980-01-02"]]))
#+END_SRC

* Misc

There is a demonstration of utilising GIS tools such as a shapefile
viewer which uses the [[http://geotools.org/][geotools API]].  This can be found in the
=grafter.gis.shape-viewer= namespace.

To run this run the following command:

#+BEGIN_SRC clojure
    (show-shapefile (io/file "./test-data/dclg-enterprise-zones/National_EZ_WGS84.shp"))
#+END_SRC
